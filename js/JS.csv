Подключение кода javascript на html-страницу осуществляется с помощью тега,"<script>
        document.write(""<h2>Первая программа на JavaScript</h2>"");
</script>",
Интерпретация,"в программировании выполнение исходного кода программы, или цикла.",
вставки кода javascript идут перед,"акрывающим тегом </body>, когда основная часть веб-страницы уже загружена в браузере.",
Комментарии могут быть,"// выводим сообщение 

 /*  Пример арифметической операции
        и определения переменной
        в коде JavaScript */</pre>",
подключим этот файл на веб-страницу index.html,"<script src=""js/myscript.js""></script>",
Для вывода различного рода информации в консоли браузера,console.log(),
код в консоли переносился на новую строку без выполнения,Shift + Enter,
Для хранения данных в программе используются,"переменные
Переменные предназначены для хранения каких-нибудь временных данных или таких данных, которые в процессе работы могут менять свое значение",
Для создания переменных применяются операторы,var и let,
Также нельзя давать переменным такие имена,которые совпадают с зарезервированными ключевыми словами,
Список зарезервированных слов в JavaScript,"await, break, case, catch, class, const, continue, debugger, default, delete, do, else, enum, export, extends, false, finally, for, function, if, import, in, instanceof, new, null, return, super, switch, this, throw, true, try, typeof, var, void, while, with, yield",
Через запятую можно определить сразу несколько переменных,"var username, age, heigt;
let a, b, c;",
Присвоение переменной значения,"После определения переменной ей можно присвоить какое-либо значение. 
Для этого применяется оператор присваивания (=):

var username;
username = ""Tom"";",
Можно сразу присвоить переменной значение при ее определении,"var username = ""Tom"";
let userage = 37;",
Процесс присвоения переменной начального значения называется,инициализацией,
Отличительной чертой переменных является то,что мы можем изменить их значение,
С помощью ключевого слова const,"можно определить константу, которая, как и переменная, хранит значение, однако это значение не может быть изменено.

const username = ""Tom"";
Если мы попробуем изменить ее значение, то мы столкнемся с ошибкой.",
при определении const мы должны ,"предоставить ей начальное значение. Если мы этого не сделаем, то опять же мы столкнемся с ошибкой:
const username; // ошибка, username не инициализирована",
В JavaScript имеется ? типов данных,8 восемь,
String:, представляет строку,
Number: ,"представляет числовое значение
представляет числа в JavaScript, которые могут быть целыми или дробными:

Целые числа, например, 35. Мы можем использовать как положительные, так и отрицательные числа. Диапазон используемых чисел: от -253 до 253

Дробные числа (числа с плавающей точкой), например, 3.5575. Опять же можно использовать как положительные, так и отрицательные числа. Для чисел с плавающей точкой используется тот же диапазон: от -253 до 253",
BigInt:," предназначен для представления очень больших целых чисел
Тип BigInt добавлен в последних стандартах JavaScript для представления очень больших целых чисел, которые выходят за пределы диапазона типа number.",
Boolean:,Тип Boolean представляет булевые или логические значения true (верно) и false (ложно),
Undefined: ,"представляет одно специальное значение - undefined и указывает, что значение не установлено",
Null:, представляет одно специальное значение - null и указывает на отсутствие значения,
Symbol: ,"представляет уникальное значение, которое часто применяется для обращения к свойствам сложных объектов",
Object: ,представляет комплексный объект,
Object представляет,"сложный, комплексный тип данных, который состоит из значений примитивных типов или других объектов. Рассмотрим основные примитивные типы данных.",
Number диапазон,-253 до 253,
Для определения числа как значения типа BigInt,"в конце числа добавляется суффикс n
let dimension = 19007n;
const value = 2545n;",
Интерполяция,"Использование косых кавычек позволяет нам применять такой прием как интерполяция - встраивать данные в строку.
let user = ""Tom"";
let text = `Name: ${user}`;
console.log(text);  // Name: Tom",
Слабая типизация,"JavaScript является языком со слабой типизацией. Это значит, что переменные могут динамически менять тип.",
typeof,"С помощью оператора typeof можно получить тип переменной:
let id;
console.log(typeof id);       // undefined
 
id = 45;
console.log(typeof id);   // number
 
id = 45n;
console.log(typeof id);     // bigint
 
id = ""45"";
console.log(typeof id);     // string",
Сложение,"let x = 10;
let y = x + 50;",
Вычитание,"let x = 100;
let y = x - 50;",
Умножение,"let x = 4;
let y = 5;
let z = x * y;",
Деление,"let x = 5;
let y = 2;
let z = x / y;
console.log(z); // 2.5",
Деление по модулю,"(оператор %) возвращает остаток от деления:

let x = 5;
let y = 2;
let z = x % y;
console.log(z); // 1",
Возведение в степень,"Оператор ** возводит число в определенную степень:

число ** степень",
Инкремент,"Оператор инкремента ++ увеличивает переменную на единицу
let x = 5;
x++; // x = 6",
префиксный инкремент,"который сначала увеличивает переменную на единицу, а затем возвращает ее значение
// префиксный инкремент
let x = 5;
let z = ++x;
console.log(x); // 6
console.log(z); // 6",
постфиксный инкремент,"который сначала возвращает значение переменной, а затем увеличивает его на единицу
// постфиксный инкремент
let a = 5;
let b = a++;
console.log(a); // 6
console.log(b); // 5",
Декремент,"уменьшает значение переменной на единицу. Также есть префиксный и постфиксный декремент
// префиксный декремент
let x = 5;
let z = --x;
console.log(x); // 4
console.log(z); // 4
     
// постфиксный декремент
let a = 5;
let b = a--;
console.log(a); // 4
console.log(b); // 5",
Операторы сравнения,"Как правило, для проверки условия используются операторы сравнения. Операторы сравнения сравнивают два значения и возвращают значение true или false",
==,"Оператор равенства сравнивает два значения, и если они равны, возвращает true, иначе возвращает false: x == 5",
===,"Оператор тождественности также сравнивает два значения и их тип, и если они равны, возвращает true, иначе возвращает false: x === 5",
!=,"Сравнивает два значения, и если они не равны, возвращает true, иначе возвращает false: x != 5",
!==,"Сравнивает два значения и их типы, и если они не равны, возвращает true, иначе возвращает false: x !== 5",
>,"Сравнивает два значения, и если первое больше второго, то возвращает true, иначе возвращает false: x > 5",
<,"Сравнивает два значения, и если первое меньше второго, то возвращает true, иначе возвращает false: x < 5",
>=,"Сравнивает два значения, и если первое больше или равно второму, то возвращает true, иначе возвращает false: x >= 5",
<=,"Сравнивает два значения, и если первое меньше или равно второму, то возвращает true, иначе возвращает false: x <= 5",
Логические операции,Логические операции применяются для объединения результатов двух операций сравнения,
&&,"Возвращает true, если обе операции сравнения возвращают true, иначе возвращает false",
||,"Возвращает true, если хотя бы одна операция сравнения возвращают true, иначе возвращает false",
!,"Возвращает true, если операция сравнения возвращает false

let isDeposit = false;
let result2 = !isDeposit;
console.log(result2); // true",
Операции присваивания,Приравнивает переменной определенное значение,
=,Приравнивает переменной определенное значение: let x = 5,
+=',"Сложение с последующим присвоением результата. Например:

let a = 23;
a += 5; // аналогично a = a + 5
console.log(a); // 28",
-=',"Вычитание с последующим присвоением результата. Например:

let a = 28;
a -= 10; // аналогично a = a - 10
console.log(a); // 18",
*=,Умножение с последующим присвоением результата,
**=,Возведение в степень с последующим присвоением результата,
/=,Деление с последующим присвоением результата,
%=,"Получение остатка от деления с последующим присвоением результата
let x = 10;
x %= 3; // аналогично x = x % 3
console.log(x); // 1, так как 10 - 3*3 = 1",
&&=,"a &&= b возвращает b, если и a и b равны true. Если какой-то из операндов равен false, то возвращается a. Аналогично выполнению a = a && b
let x = true;
let y = false;
y &&= x;
console.log(y); // false
 
let c = false;
let d = true;
c &&= d;
console.log(c); // false
 
let a = true;
let b = true;
a &&= b;
console.log(a); // true
 
let e = false;
let f = false;
e &&= f;
console.log(e); // false",
||=,"a ||= b эквивалентно выражению a = a || b:

let x = true;
let y = false;
y ||= x;
console.log(y); // true
 
let a = true;
let b = true;
a ||= b;
console.log(a); // true
 
let c = false;
let d = true;
c ||= d;
console.log(c); // true
 
let e = false;
let f = false;
e ||= f;
console.log(e); // false",
Тернарная операция,"Тернарная операция состоит из трех операндов и имеет следующее определение
[первый операнд - условие] ? [второй операнд] : [третий операнд]

",
Оператор ??,"Оператор ?? (nullish coalescing operator) позволяет проверить значение на null и undefined. Он принимает два операнда:

const result1 = ""hello"" ?? ""world"";
console.log(result1);   // hello
 
const result2 = 0 ?? 5;
console.log(result2);   // 0
 
const result3 = """" ?? ""javascript"";
console.log(result3);   // """" - пустая строка
 
const result4 = false ?? true;
console.log(result4);   // false",
Оператор =??,"Оператор ?? имеет модификацию в виде оператора ??=, который также позволяет проверить значение на null и undefined. Он принимает два операнда:

левый_операнд ??= правый_операнд
Если левый операнд равен null и undefined, то ему присваивается значение правого операнда. Иначе левый операнд сохраняет свое значение. Например:

let message = ""Welcome to JavaScript"";
let text = ""Hello work!""
text ??= message;
console.log(text);  // Hello work!",
parseInt(),"Для преобразования строки в целое число применяется функция parseInt()

let number1 = ""56"";
let number2 = 4;
let result = parseInt(number1) + number2;
console.log(result); // 60

При этом строка может иметь смешанное содержимое, например, ""123hello"", то есть в данном случае есть цифры, но есть и обычные символы. Функция parseInt() все равно попытается выполнить преобразование - она последовательно, начиная с первого символа, считывает цифры, пока не встретит первый нецифровой символ:

let num1 = ""123hello"";
let num2 = parseInt(num1);
console.log(num2); // 123",
NaN,"Если функции parseInt() не удастся выполнить преобразование, то он возвращает значение NaN (Not a Number), которое говорит о том, что строка не представляет число и не может быть преобразована

console.log(parseInt(""abc""));   // NaN
let type = typeof NaN;
console.log(type);",
 isNaN() ,"С помощью специальной функции isNaN() можно проверить, представляет ли строка число. Если строка не является числом, то функция возвращает true, если это число - то false:

let num1 = ""javascript"";
let num2 = ""22"";
let result = isNaN(num1);
console.log(result); // true - num1 не является числом
     
result = isNaN(num2);
console.log(result); //  false - num2 - это число",
Преобразование в другой системе исчисления,"Выше мы рассматривали перевод строк в числа в десятичной системе. Но мы можем с помощью второго параметра явно указать, что хотим преобразовать строку в число в определенной системе. Например, преобразование в число в двоичной системе:

let num1 = ""110"";
let num2 = parseInt(num1, 2);
console.log(num2); // 6
Результатом будет 6, так как 110 в двоичной системе - это число 6 в десятичной",
parseFloat(),"Для преобразования строк в дробные числа применяется функция parseFloat(), которая работает аналогичным образом:

let number1 = ""46.07"";
let number2 = ""4.98"";
let result = parseFloat(number1) + parseFloat(number2);
console.log(result); //51.05",
массивы,"Для работы с наборами данных предназначены массивы. Для создания массива применяются квадратные скобки []. Внутри квадратных скобок определяются элементы массива.

Простейшее определение массива:
const myArray = []",
JavaScript массивы не являются строго типизированными,"один массив может хранить данные разных типов:

const objects = [""Tom"", 12, true, 3.14, false];
console.log(objects);",
Многомерные массивы,"Каждый элемент в многомерном массиве может представлять собой отдельный массив.

const numbers1 = [0, 1, 2, 3, 4, 5 ]; // одномерный массив
const numbers2 = [[0, 1, 2], [3, 4, 5] ]; // двумерный масси",
Условные конструкции,Условные конструкции позволяют выполнить те или иные действия в зависимости от определенных условий,
Конструкция if..else,"Конструкция if..else проверяет некоторое условие и если это условие верно, то выполняет некоторые действия. Простейшая форма конструкции if..else:

if(условие){
    некоторые действия
}

онструкцию можно упростить, убрав фигурные скобки и поместив действия сразу после условия:

const income = 100;
if(income > 50) console.log(""доход больше 50"");

или перенести действия на следующую строку

const income = 100;
if(income > 50) 
    console.log(""доход больше 50"");",
Проверка наличия значения,"Конструкция if позволяет проверить наличие значения. Например:

let myVar = 89;
if(myVar){
     
    console.log(`Переменная myVar имеет значение: ${myVar}`);
}
Если переменная myVar имеет значение, как в данном случае, то в условной конструкции она возвратит значение true.

Противоположный вариант:

let myVar;
if(myVar){
    console.log(`Переменная myVar имеет значение: ${myVar}`);
}
Здесь переменная myVar не имеет значения. (В реальности она равна undefined) Поэтому условие в конструкии if возвратит false, и действия в блоке конструкции if не будут выполняться.

Но нередко для проверки значения переменной используют альтернативный вариант - проверяют на значение undefined и null:

if (myVar !== undefined && myVar !== null) {
    console.log(`Переменная myVar имеет значение: ${myVar}`);
}",
Выражение else,"Данный блок содержит инструкции, которые выполняются, если условие после if ложно, то есть равно false:

if(условие){
    действия, если условие истинно
}
else{
    действия, если условие ложно
}",
Альтернативные условия и else if,"С помощью конструкции else if мы можем добавить альтернативное условие к блоку if. Например, выше в условие значение income может быть больше определенном значению может быть меньше, а может быть равно ему. Отразим это в коде:


const income = 50;
if(income > 50) {
    console.log(""Доход больше 50"");
}
else if(income === 50){
    console.log(""Доход равен 50"");
}
else{
    console.log(""Доход меньше 50"");
}",
True или false - undefined,Возвращает false,
True или false - null,Возвращает false,
True или false - Boolean,"Если константа/переменная равна false, то возвращается false. Соответствено если константа/переменная равна true, то возвращается true",
True или false - Number,"Возвращает false, если число равно 0 или NaN (Not a Number), в остальных случаях возвращается true

Например, следующая переменная будет возращать false:

let x = NaN;
if(x){  // false
 }",
True или false - String,"Возвращает false, если константа/переменная равна пустой строке, то есть ее длина равна 0, в остальных случаях возвращается true

const emptyText = """";   // false - так как пустая строка
const someText = ""javascript"";  // true - строка не пустая",
True или false - Object,"Всегда возвращает true

const user = {name:""Tom""};  // true
const car = {}; // true",
Конструкция switch..case,"Конструкция switch..case является альтернативой использованию конструкции if..else и также позволяет обработать сразу несколько условий:

const income = 300;
switch(income){
 
    case 100 : 
        console.log(""Доход равен 100"");
        break;
    case 200 : 
        console.log(""Доход равен 200"");
        break;
    case 300 : 
        console.log(""Доход равен 300"");
        break;
}

После ключевого слова switch в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями, помещенными после оператора сase. И если совпадение будет найдено, то будет выполняться определенный блок сase.

В конце каждого блока сase ставится оператор break, чтобы избежать выполнения других блоков.

Однако при необходимости можно сразу обработать несколько условий:
const income = 200;
switch(income){
 
    case 100 :
    case 200 :
        console.log(""Доход равен 100 или 200"");
        break;
    case 300 : 
        console.log(""Доход равен 300"");
        break;
}",
Конструкция switch..case - default:,"Если мы хотим также обработать ситуацию, когда совпадения не будет найдено, то можно добавить необязательный блок default:

const income = 300;
switch(income){
 
    case 100 : 
        console.log(""Доход равен 100"");
        break;
    case 200 : 
        console.log(""Доход равен 200"");
        break;
    case 300 : 
        console.log(""Доход равен 300"");
        break;
    default: 
        console.log(""Доход неизвестной величины"");
        break;
}",
Циклы,Циклы позволяют в зависимости от определенных условий выполнять некоторое действие множество раз,
В JavaScript имеются следующие виды циклов,"for

for..in

for..of

while

do..while

(5 видов)",
Цикл for,"Цикл for имеет следующее формальное определение:

for ([инициализация счетчика]; [условие]; [изменение счетчика]){
 
    // действия
}

Например, используем цикл for для перебора чисел от 0 до 4:

for(let i = 0; i<5; i++){
     console.log(i);
}
console.log(""Конец работы"");

При этом можно опускать различные части объявления цикла:

let i = 0;
for(; i < 60;){
      
    console.log(i);
    i = i + 10;
}",
Применение нескольких счетчиков в цикле,"При необходимости можно использовать несколько счетчиков:

for(let i = 1, j=1; i < 5, j < 4; i++, j++){
    console.log(i + j);
}
// 1 итерация: i=1, j=1; i + j = 2
// 2 итерация: i=2, j=2; i + j = 4
// 3 итерация: i=3, j=3; i + j = 6",
Вложенные циклы,"Одни циклы могут внутри себя содержать другие:

for(let i=1; i <= 5; i++){
      
     for(let j = 1; j <=5; j++){
        console.log(i * j);
     }
}",
Цикл while,"Цикл while выполняется до тех пор, пока некоторое условие истинно. Его формальное определение:

while(условие){
    // действия
}
Опять же выведем с помощью while числа от 1 до 5:

let i = 1;
while(i <=5){
     console.log(i);
    i++;
}",
Цикл  do..while,"В цикле do сначала выполняется код цикла, а потом происходит проверка условия в инструкции while. И пока это условие истинно, цикл повторяется. Например:

let i = 1;
do{
    console.log(i);
    i++;
}while(i <= 5)
Здесь код цикла сработает 5 раз, пока i не станет равным 5. При этом цикл do гарантирует хотя бы однократное выполнение действий, даже если условие в инструкции while не будет истинно.",
Операторы continue,"Иногда бывает необходимо выйти из цикла до его завершения. В этом случае мы можем воспользоваться оператором break:

for(let i=1; i <= 10; i++){
      
     if(i===6) break;
     console.log(i);
}
console.log(""Конец работы"");

Данный цикл увеличивает переменную i c 1 до 10 включая, то есть согласно условию цикла блок цикла должен выполняться 10 раз, то есть поизвести 10 итераций. Однако поскольку в блоке цикла происходит поверка if(i===6) break;, то, когда значение переменной i достигнет 6, то данное условие прервет выполнение цикла с помощью оператора break. И цикл заершит работу.",
Операторы break,"Если нам надо просто пропустить итерацию, но не выходить из цикла, мы можем применять оператор continue:

for(let i=1; i <= 10; i++){
      
     if(i===6) continue;
     console.log(i);
}
console.log(""Конец работы"");
В этом случае, когда значение переменной i станет равным 6, то в цикле конструкция if(i===6) continue завершит текущую итерацию, далее идущие инструкции цикла не будут выполняться, и произойдет переход к следующей итерации:",
Цикл for..in,"Цикл for..in предназначен главным образом для перебора объектов. Его формальное определение:

for (свойство in объект) {
    // действия
}
Этот цикл перебирает все свойства объекта. Например:

const person = {name: ""Tom"", age: 37};
for(prop in person){
      
     console.log(prop);
}
Здесь перебирается объек person, который имеет два свойства - name и age. Соответственно на консоли мы увидим:
name
age",
Цикл for...of,"Цикл for...of предназначен для перебора наборов данных. Например, строка представляет фактически набор символов. И мы можем перебрать ее с помощью данного цикла:

const website = ""METANIT.COM"";
for(ch of website){
      
     console.log(ch);
}
В итоге цикл перебирает все символы строки website и помещает каждый текущий символ в переменную ch, значение которой затем выводится на консоль.

Другим примером может быть перебор массива:

const people = [""Tom"", ""Sam"", ""Bob""];
for(const person of people) {
    console.log(person);
}
В данном случае цикл перебирает элементы массива people. Каждый элемент последовательно помещается в константу person. И далее мы можем вывести ее значение на консоль",
Функции,"Функции представляют собой набор инструкций, которые выполняют определенное действие или вычисляют определенное значение.

Синтаксис определения функции:
function имя_функции([параметр [, ...]]){
    // Инструкции
}

Общий синтаксис вызова функции: 
имя_функции(параметры)

Отличительной чертой функций является то, что их можно многократно вызывать в различных местах программы.",
Переменные и константы в качестве функций,"Подобно тому, как константам и переменным присваиваются простейшие значения (числа, строки и т.д.), также им можно присваивать функции. Затем через такую переменную или константу можно вызвать присвоенную ей функцию.

function hello(){
    console.log(""Hello from Metanit.com"");
}
// передача константе message ссылки на функцию hello
const message = hello;
message();",
Анонимные функции,"Необязательно давать функциям определенное имя. Можно использовать анонимные функции:

let message = function(){
    console.log(""Hello JavaScript"");
}
message();

var name=""admin""    
    setTimeout(function(){
        alert(name);
    },1000);",
Параметры функции (аргументы),"Функция в JavaScript может принимать параметры. Параметры представляют способ передачи в функцию данных. Параметры указываются в скобках после названия функции.

function print(message){
    console.log(message);
}

Если параметру не передается значение, тогда он будет иметь значение undefined.
Если функция принимает несколько параметров, то они перечисляются через запятую.",
Необязательные параметры и значения по умолчанию,"Функция может принимать множество параметров, но при этом часть или все параметры могут быть необязательными. Если для параметров не передается значение, то по умолчанию они имеют значение ""undefined"". Однако иногда бывает необходимо, чтобы параметры обязательно имели какие-то значения, например, значения по умолчанию.

function sum(x = 8, y = 5){
     const z = x + y;
    console.log(z);
}
sum();      // 13
sum(6);     // 11
sum(6, 4)   // 10",
Массив arguments,"Объект arguments — это подобный массиву объект, который содержит аргументы, переданные в функцию.
При необходимости мы можем получить все переданные параметры через глобально доступный массив arguments:

function sum(){
    let result = 0;
    for(const n of arguments)
        result += n;
    console.log(result);
}
sum(6);             // 6
sum(6, 4)           // 10
sum(6, 4, 5)        // 15
При этом даже не важно, что при определении функции мы не указали никаких параметров, мы все равно можем их передать и получить их значения через массив arguments.",
Остаточные параметры (rest parameters) …,"Синтаксис остаточных параметров функции позволяет представлять неограниченное множество аргументов в виде массива.
function display(season, ...temps){
    console.log(season);
    for(index in temps){
        console.log(temps[index]);
    }
}
display(""Весна"", -2, -3, 4, 2, 5);
display(""Лето"", 20, 23, 31);
В данном случае второй параметр ...temps указывает, что вместо него можно передать разное количество значений. В самой функции temps фактически представляет массив переданных значений, которые мы можем получить. При этом несмотря на это, при вызове функции в нее передается не массив, а именно отдельные значения.

Консольный вывод:

Весна
-2
-3
4
2
5
Лето
20
23
31",
Функции в качестве параметров,"Функции могут выступать в качестве параметров других функций:
function sum(x, y){
    return x + y;
}
 
function subtract(x, y){
    return x - y;
}
 
function operation(x, y, func){
  
    const result = func(x, y);
    console.log(result);
}
 
console.log(""Sum"");
operation(10, 6, sum);  // 16
 
console.log(""Subtract"");
operation(10, 6, subtract); // 4

Функция operation принимает три параметра: x, y и func. func - представляет функцию, причем на момент определения operation не важно, что это будет за функция. Единственное, что известно, что функция func может принимать два параметра и возвращать значение, которое затем отображается в консоли браузера. Поэтому мы можем определить различные функции (например, функции sum и subtract в данном случае) и передавать их в вызов функции operation",
Результат функции,"Функция может возвращать результат. Для этого используется оператор return, после которого указывается возвращаемое значение:

function sum (a, b) {
    const result = a + b;
    return result;
}",
Возвращение функции из функции,"Одна функция может возвращать другую функцию:

function menu(n){
  
    if(n==1) return function(x, y){ return x + y;}
    else if(n==2) return function(x, y){ return x - y;}
    else if(n==3) return function(x, y){ return x * y;}
    return function(){ return 0;}
}
 
const action = menu(1);         // выбираем первый пункт - сложение
const result = action(2, 5);    // выполняем функцию и получаем результат в константу result
console.log(result);

В данном случае функция menu() в зависимости от переданного в нее значения возвращает одну из трех функций или пустую функцию, которая просто возвращает число 0",
Область видимости переменных,"Все переменные и константы в JavaScript имеют определенную область видимости, в пределах которой они могут действовать.",
Глобальные переменные,"Все переменные и константы, которые объявлены вне функций, являются глобальными",
Определение локальной области видимости,"Для определения локальной области видимости в JavaScript используются фигурные скобки { }, которые создают блок кода. Этот блок кода может быть безымянным, может быть именнованным, например, функция, либо может представлять условную или циклическую конструкцию. Например, определение переменных в безымянном блоке кода:

{
    var a = 5;
    let b = 8;
    const c = 9;
}
Однако в этом случае поведение переменной зависит от способа ее определения (через var или через let) и от типа блока. var определяет локальные переменные уровня функции, а let определяет локальные переменные уровня блока кода (подобным образом const определяет константы уровня блока кода)",
"Переменные и константы, определенные внутри функции ","видны (то есть могут использоваться) только внутри этой функции.
Подобное поведение не зависит от того, что это за переменная - var или let, либо это константа. Подобное поведение для всех переменных и констант одинаково",
"Локальные переменные в блоках кода, условиях и циклах","Переменная var Переменная, объявленная с помощью var, может использоваться вне блока
Переменная let и константы Мы можем использовать переменные let, определенные внутри блока кода, можно использовать только внутри этого блока кода.",
Скрытие переменных,"если у нас есть две переменных - одна глобальная, а другая локальная, которые имеют одинаковое имя:  
var z = 89;
 function print(){     
  var z = 10;     console.log(z); // 10
 } 
print(); // 10 
В этом случае в функции будет использоваться та переменная z, которая определена непосредственно в функции. То есть локальная переменная скроет глобальную. Однако конкретное поведение при сокрытии зависит от того, как определяется переменная",
Скрытие переменной var,"var определяет переменную уровня функции. Поэтому с помощью оператора var мы НЕ можем определить одновременно две переменных с одним и тем же именем и в функции, и в блоке кода в этой функции. Если мы это сделаем, то при объявлении переменной на уровне блока мы меняем значение переменной уровня функции:

function displayZ(){
      var z = 20;
      {
        var z = 30; // Не определяет новую переменную, а изменяет значение переменной z уровня функции
        console.log(""Block:"", z);
    }
    console.log(""Function:"", z);
}
displayZ();",
Скрытие переменной let,"Оператор let определяет переменную уровня блока кода. То есть каждый блок кода определяет новую область видимости, в которой существует переменная. Ве блока кода, где определена переменная, она не существует. Соответственно мы можем одновременно определить переменную на уровне блока и на уровне функции (в отличие от var)",
Скрытие Константы,"Все, что относится к оператору let, относится и к оператору const, который определяет константы уровня блока кода. Блоки кода задают область видимости констант, а константы, определенные на вложенных блоках кода, скрывают внешние константы с тем же именем.",
Необъявленные переменные,"Если мы не используем это ключевое слово при определении переменной в функции, то такая переменная будет глобальной. Например:

function bar(){
    foo = ""25"";
}
bar();
console.log(foo);   // 25

 Единственное условие - мы вызываем функцию, где определена такая переменная.",
"strict mode ""use strict""","Определение глобальных переменных в функциях может вести к потенциальным ошибкам. Чтобы их избежать используется строгий режим или strict mode:

""use strict"";
function bar(){
    foo = ""25"";     // Uncaught ReferenceError: foo is not defined
}
  
bar();
console.log(foo);

В этом случае мы получим ошибку SyntaxError: Unexpected identifier, которая говорит о том, что переменная foo не определена.

Установить режим strict mode можно двумя способами:

добавить выражение ""use strict"" в начало кода JavaScript, тогда strict mode будет применяться для всего кода

добавить выражение ""use strict"" в начало тела функции, тогда strict mode будет применяться только для этой функции. Пример использования на уровне функции:

function bar(){
     ""use strict"";
    foo = ""25"";
}",
Замыкание (closure),"Замыкание (closure) представляют собой конструкцию, когда функция, созданная в одной области видимости, запоминает свое лексическое окружение даже в том случае, когда она выполняет вне своей области видимости.

Рассмотрим замыкания на простейшем примере:

function outer(){
    let x = 5;
    function inner(){
        x++;
        console.log(x);
    };
    return inner;
}
let fn = outer();   // fn = inner, так как функция outer возвращает функцию inner
// вызываем внутреннюю функцию inner
fn();   // 6
fn();   // 7
fn();   // 8
Здесь функция outer задает область видимости, в которой определены внутренняя функция inner и переменная x. Переменная x представляет лексическое окружение для функции inner. В самой функции inner инкрементируем переменную x и выводим ее значение на консоль. В конце функция outer возвращает функцию inner",
Замыкание технически включает три компонента,"- внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные - лексическое окружение

- переменные (лексическое окружение), которые определены во внешней функции

- вложенная функция, которая использует эти переменные


function outer(){       // внешняя функция
    var n;              // некоторая переменная
    return inner(){     // вложенная функция
        // действия с переменной n
    }
}",
Самовызывающиеся функции,"Обычно определение функции отделяется от ее вызова: сначала мы определяем функцию, а потом вызываем. Но это необязательно. Мы также можем создать такие функции, которые будут вызываться сразу при определении. Такие функции еще называют Immediately Invoked Function Expression (IIFE).

(function(){
    console.log(""Привет мир"");
}());
 
(function (n){
     
    var result = 1;
    for(var i=1; i<=n; i++)
        result *=i;
    console.log(""Факториал числа "" + n + "" равен "" + result);
}(4));
Подобные функции заключаются в скобки, и после определения функции идет в скобках передача параметров.",
Факториал числа,"это число, умноженное на ""себя минус один"" , затем на ""себя минус два"" , и так далее до 1 . Факториал n обозначается как n!

",
Паттерн Модуль,"Паттерн ""Модуль"" базируется на замыканиях и состоит из двух компонентов: внешняя функция, которая определяет лексическое окружение, и возвращаемый набор внутренних функций, которые имеют доступ к этому окружению.

Определим простейший модуль:

let foo = (function(){
    let obj = {greeting: ""hello""};
     
    return {
        display: function(){
            console.log(obj.greeting);
        }
    }
})();
foo.display();  // hello",https://metanit.com/web/javascript/3.9.php
Реку?рсия,"Реку?рсия — определение, описание, изображение какого-либо объекта или процесса внутри самого этого объекта или процесса, то есть ситуация, когда объект является частью самого себя.",
Рекурсивные функции,"Среди функций отдельно можно выделить рекурсивные функции. Их суть состоит в том, что функция вызывает саму себя.

Например, рассмотрим функцию, определяющую факториал числа:

function getFactorial(n){
    if (n === 1){
        return 1;
    }
    else{
         
        return n * getFactorial(n - 1);
    }
}
var result = getFactorial(4); 
console.log(result); // 24",
Требования рекурсии,"Простой базовый случай, или терминальный сценарий, или терминальное условие. Простыми словами, когда остановиться. В нашем примере это был 0: мы остановили вычисление факториала, когда достигли 0.

Правило передвижения по рекурсии, углубление. В нашем случае, это было n * factorial(n-1",
Переопределение функций,"Функции обладают возможностью для переопределения поведения. Переопределение происходит с помощью присвоения анонимной функции переменной, которая называется так же, как и переопределяемая функция:

function display(){
    console.log(""Доброе утро"");
    display = function(){
        console.log(""Добрый день"");
    }
}
 
display(); // Доброе утро
display(); // Добрый день

При первом срабатывании функции действует основной блок операторов функции, в частности, в данном случае выводится сообщение ""Доброе утро"". И при первом срабатывании функции display также происходит ее переопределение. Поэтому при всех последующих вызовах функции срабатывает ее переопределенная версия, а на консоль будет выводиться сообщение ""Добрый день"".

Но при переопределении функции надо учитывать некоторые нюансы. В частности, попробуем присвоить ссылку на функцию переменной и через эту переменную вызвать функцию:

function display(){
    console.log(""Доброе утро"");
    display = function(){
        console.log(""Добрый день"");
    }
}
// присвоение ссылки на функцию до переопределения
var displayMessage = display;
display(); // Доброе утро
display(); // Добрый день
displayMessage(); // Доброе утро
displayMessage(); // Доброе утро",
